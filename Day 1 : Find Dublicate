Introduction
This repository contains an implementation of Floyd's Tortoise and Hare algorithm to find the duplicate number in an array. The algorithm efficiently finds the duplicate without modifying the array and with a time complexity of O(n) and a space complexity of O(1).

Problem Statement
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive, there is exactly one repeated number. Your task is to find this duplicate number.

Algorithm Explanation
The algorithm uses the cycle detection method, known as Floyd's Tortoise and Hare algorithm, to detect the duplicate number. The array can be viewed as a linked list where each element points to the index of the next element. Since there is a duplicate, there must be a cycle in this linked list.

Phase 1: Finding the Intersection Point
We initialize two pointers, slow and fast, both starting at the first element of the array.
slow moves one step at a time, while fast moves two steps at a time.
When slow and fast meet, it indicates the presence of a cycle.
Phase 2: Finding the Entrance to the Cycle
We reset slow to the start of the array.
Both slow and fast move one step at a time until they meet again.
The meeting point is the entrance to the cycle, which is the duplicate number.
Code
Here is the implementation of the algorithm in C++:

#include <vector>
using namespace std;

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = nums[0];
        int fast = nums[0];

        // Find the intersection point of the two pointers
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        // Find the entrance of the cycle
        slow = nums[0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }

        return slow;
    }
};

Initial State:
nums = [2, 6, 4, 1, 3, 1, 5]
slow = nums[0] = 2
fast = nums[0] = 2
Phase 1: Finding the Intersection Point
In this phase, we will move slow by one step and fast by two steps until they meet inside the cycle.

First iteration:

slow = nums[slow] = nums[2] = 4
fast = nums[nums[fast]] = nums[nums[2]] = nums[4] = 3
Now, slow = 4 and fast = 3
Second iteration:

slow = nums[slow] = nums[4] = 3
fast = nums[nums[fast]] = nums[nums[3]] = nums[1] = 6
Now, slow = 3 and fast = 6
Third iteration:

slow = nums[slow] = nums[3] = 1
fast = nums[nums[fast]] = nums[nums[6]] = nums[5] = 1
Now, slow = 1 and fast = 1
They meet at 1, so we found the intersection point.

Phase 2: Finding the Entrance to the Cycle
In this phase, we reset slow to the start of the array and move both pointers one step at a time until they meet at the entrance of the cycle (which is the duplicate number).

Initialization:

slow = nums[0] = 2
fast = 1 (from the intersection point)
First iteration:

slow = nums[slow] = nums[2] = 4
fast = nums[fast] = nums[1] = 6
Now, slow = 4 and fast = 6
Second iteration:

slow = nums[slow] = nums[4] = 3
fast = nums[fast] = nums[6] = 5
Now, slow = 3 and fast = 5
Third iteration:

slow = nums[slow] = nums[3] = 1
fast = nums[fast] = nums[5] = 1
Now, slow = 1 and fast = 1
They meet at 1, so the entrance to the cycle (and the duplicate number) is 1.

Conclusion
The duplicate number in the array [2, 6, 4, 1, 3, 1, 5] is 1. The algorithm correctly identifies 1 as the duplicate.
